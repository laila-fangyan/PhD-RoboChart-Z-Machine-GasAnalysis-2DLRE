[%
/*
"TOTAL SIZE".println();
RC!RCPackage.size().println();
var statemachine_name: String;
for (p in RC!RCPackage)
{ 
"PRINT .machines.SIZE".println();
p.machines.size().println();
"PRINT p.machines.at(0).name;".println();
statemachine_name=p.machines.at(0).name;
statemachine_name.println();
}*/

var stm_name: String;
for (stm in RC!StateMachineDef.allInstances)
{ 
stm_name=stm.name;
}

 var javaDate = new Native("java.text.SimpleDateFormat")("ddMMyyyy_hhmmss").
  format(new Native("java.util.Date"));
 var javaDateString = new String;
 javaDateString= javaDate.toString();

%]
theory [%=stm_name%]_[%=javaDateString%]
imports "Z_Machines.Z_Machine"
begin

notation undefined ("???")

subsection \<open> Introduction \<close>

text \<open> This theory file is to model the [%=stm_name%] state machine in Z Machine notations.\<close>

subsection \<open> type definition \<close>

[%
for (p in RC!RCPackage) {
if (p.name="Chemical" or p.name="lre_beh"){
 
//////////////////////////////////////////////////////////////////////////////////////////////////
//query the states  to generate enumtype
"////////////////////////////////////////////////////////////////////////////////".println();
"Query the states".println();
//we assume there is ONLY ONE state machine in the package
//p.machines.at(0).nodes.size().println();
 
var k=0;
//var state_set: OrderedSet;
// type 'Set' is not working as it add the new element in random order, 
//not always add to the end but may insert in the middle somewhere
var enum_output: String;
var set_output: String;
/* 
for (n in p.machines.at(0).nodes){
if (n.isTypeOf(Initial)){
("Initial name: " +n.name).println();
}
enum_output= enum_output+ n.name +" | ";
set_output= set_output+ n.name +", ";
if (n.isTypeOf(State)){
enum_output= enum_output+ n.name +" | ";
set_output= set_output+ n.name +", ";
}
 }
// there is no need to differenriate the Initial State. they are two different types
//but they are both nodes, so we only query nodes, that's enough.
so the code above can be replaced by the 3 lines below.
*/
 p.machines.println();

 for (n in p.machines.at(0).nodes){
 enum_output= enum_output+ n.zmState() +" | ";
set_output= set_output+ n.zmState() +", ";}
 
 //to add the context for thy file "enumtype ProperState = "
//to add the initial, initial is a juction, not a state, so can not be queried through state
//to cut the last vertical bar
enum_output= "enumtype ProperState = " + enum_output.substring(0,(enum_output.length()-2));
%]
[%=enum_output%]
[%set_output= "definition \"ProperState = {" + set_output.substring(0,(set_output.length()-2))+"}\"";
%]

[%=set_output%] 

[%
//////////////////////////////////////////////////////////////////////////////////////////////////
//query the TYPES
"////////////////////////////////////////////////////////////////////////////////".println();
"Query the types".println();
/////////////////////////////////////////////////////////////////////
//for Enumaration type
for (e in p.types)
{
e.type().name.println();
("e.name: " + e.name).println();
 if(e.type().name="Enumeration"){
 var enumtype_output: String;
 var enumtype_set_output: String;
 var i=0;
while(i<e.literals.size()){
//("literal "+ i +": " + e.literals.at(i).name).println();
enumtype_output=enumtype_output+ e.literals.at(i).name +" | ";
enumtype_set_output=enumtype_set_output+ e.literals.at(i).name +", ";
i++;
}
enumtype_output="enumtype "+ e.name + " = "+ enumtype_output.subString(0, (enumtype_output.length()-3));
("final enumtype_output: " +enumtype_output).println();
%]
[%=enumtype_output%]

[%enumtype_set_output="definition \""+ e.name + " = {"+ enumtype_set_output.subString(0, (enumtype_set_output.length()-2))+ "}\"";
("final enumtype_set_output: " +enumtype_set_output).println();%]
[%=enumtype_set_output%]

[%
 }
}

/////////////////////////////////////////////////////////////////////
//for Primitive type
//I repeat "for(e in p.types)" for primitive, record, instead of put all types under one "for(e in p.types)"
//the reason is that I need to generate primitive type first, then the record type which use the primitive type
//in RoboChart these two types can be defined in either order
//but in thy primitive for the record has to be defined first, then be used in record
"/////////////////////////////////////////////////////////////////////".println();
"query for primitive type".println();
for (e in p.types)
{
 if(e.type().name="PrimitiveType"){
  var primitiveType_output: String;
  primitiveType_output="type_synonym " + e.name + "= \"nat\"";
  primitiveType_output.println();%]
[%=primitiveType_output%]
  
 [%}
 }


/////////////////////////////////////////////////////////////////////
//for Record type
"/////////////////////////////////////////////////////////////////////".println();
"query for record type".println();
for (e in p.types)
{
 if(e.type().name="RecordType"){%]
record [%=e.name%] =
 [%
 // var recordType_output: String;
  var i=0;
while(i<e.fields.size()){
(e.fields.at(i).name + " :: " + e.fields.at(i).Type.ref.name).println();%]
  [%=e.fields.at(i).name%] :: [%=e.fields.at(i).Type.ref.name%]
[%//recordType_output=e.fields.at(i).name + " :: " + e.fields.at(i).Type.ref.name;
i++;
}
("record_default " + e.name).println();%]
record_default [%=e.name%]
[%//recordType_output="record " + e.name + "= "+ recordType_output;
//("recordType_output: " + recordType_output).println();
 }
}
  
/////////////////////////////////////////////////////////////////////
//for Constants
"/////////////////////////////////////////////////////////////////////".println();
"query for constants definition".println(); 

for (vrl in p.machines.at(0).variableList)
{
"vrl".println();
vrl.println();

("vrl.vars.size(): "+vrl.vars.size()).println();
 "".println();
//("vrl.var): "+vrl.vars).println();
//vrl.modifier.literal.println();
//vrl.vars.at(i).modifier.literal.println();
//vrl.vars.at(i).modifier.literal.at(0).println();
var i=0;
while(i< vrl.vars.size()){
//vrl.vars.at(i).at(0).type.println();
var const_string: String;

if(vrl.vars.at(i).modifier.literal="CONST"){

if(vrl.vars.at(i).type.isTypeOf(TypeRef)){
const_string="consts "+vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.ref.name +"\"";
("const_string: " +const_string).println();
 "".println();
}
else if(vrl.vars.at(i).type.isTypeOf(SeqType)){
const_string="consts "+vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.domain.ref.name +" list\"";
}}
%]
[%=const_string%]
  [%
i++;} }
 
 
 

/////////////////////////////////////////////////////////////////////
//query for functions to generate consts func or zfun
"/////////////////////////////////////////////////////////////////////".println();
"query for functions".println();%]

text \<open> function definition \<close>

[%
//function card is not used in the GasAnalysis, so I FILTER IT OUT
//another MAJOR reason is that card.type()=SetType
//SetType is the parent of SeqType, 
//so it has property 'domain' too
//currently, I am using the difference in the property between SeqType and other TypeRef
//but both SetType and SeqType has domain.
//For GasAnalysis use case, it is okay,
//but for other use cases, if both types are used, I then have to find another way to differentiate them

//TO Transform functions into CONSTS for the UNSPECIFIED Functions
for (f in p.functions.select(s|s.name!="card" and s.preconditions.isEmpty() and s.postconditions.isEmpty))
{ 
var function_string: String;
//f.name.println();
//f.type.ref.name.println();
//f.parameters.size().println();
//f.parameters.at(0).name.println();
//be CAREFUL, type and type() are different
//type is the property, to return the type defined in the use case
//type() is the method, to return the class in the metamodel
//they return different value: SeqType, parameter
//f.parameters.at(0).type.println();
//f.parameters.at(0).type().println();
//f.parameters.at(0).type().name.println();


//CASE 1: single parameter
//pattern: consts f.name :: " parameter_type => f.type"
if(f.parameters.size()=1){

//TO DO
//here I only consider the parameter type to be SeqType
// I have not consider the function type to be SeqType
if(f.parameters.at(0).type.isTypeOf(SeqType)){
"this is a SeqType".println();
("consts "+f.name+ " :: \" "+ f.parameters.at(0).type.domain.ref.name +" list \\<Rightarrow> "+ f.type.ref.name+"\"").println();
function_string="consts "+f.name+ " :: \" "+ f.parameters.at(0).type.domain.ref.name +" list \\<Rightarrow> "+ f.type.zmType()+"\"";
}else if(f.parameters.at(0).type.isTypeOf(TypeRef)){
("consts "+f.name+ " :: \" "+ f.parameters.at(0).type.zmType() +" \\<Rightarrow> "+ f.type.ref.name+"\"").println();
//function_string= "consts "+f.name+ " :: \" "+ f.parameters.at(0).type.ref.name +" \\<Rightarrow> "+ f.type.ref.name+"\"";
function_string= "consts "+f.name+ " :: \" "+ f.parameters.at(0).type.zmType() +" \\<Rightarrow> "+ f.type.zmType()+"\"";
}}
//CASE 2: multiple parameters, we will need pXp pattern in ZM
//pattern: consts f.name :: " parameter_type (X parameter_type)* => f.type"
else if(f.parameters.size()>1){

// generate the first part of parameter
if(f.parameters.at(0).type.isTypeOf(SeqType)){
"SeqType domain: ".println();
f.parameters.at(0).type.domain.ref.name.println();
function_string=f.parameters.at(0).type.domain.ref.name;
} else if(f.parameters.at(0).type.isTypeOf(TypeRef)){
f.parameters.at(0).type.zmType().println();
function_string=f.parameters.at(0).type.zmType();
}

// generate the rest part of parameter: (X parameter_type)*
var i=1;
while(i<f.parameters.size()){


if(f.parameters.at(i).type.isTypeOf(SeqType)){
"SeqType domain: ".println();
f.parameters.at(i).type.domain.ref.name.println();
function_string=function_string+" \\<times> " + f.parameters.at(i).type.domain.ref.name;
} else if(f.parameters.at(i).type.isTypeOf(TypeRef)){
f.parameters.at(i).type.zmType().println();
function_string=function_string+" \\<times> " + f.parameters.at(i).type.zmType();
}

i++;
}
function_string="consts "+f.name+ " :: \" "+function_string+" \\<Rightarrow>"+ f.type.zmType()+"\"";
"OUTPUT FUNCTION STRING:".println();
function_string.println();

}

%]
[%=function_string%]
[%

//if(f.preconditions.isDefined()){
//f.preconditions.println();}
//if(f.postconditions.isDefined()){
//f.postconditions.println();}
//"OUTPUT:".println();
//("consts "+f.name + " :: \""+
}



//////////////////////////////////////
//To transform SPECIFIED functions into zfun
for (f in p.functions.select(s|s.name!="card")){
var function_string: String;
var precond_string: String;
var postcond_string: String;

//I need to keep this IF for a while as not all functions are realized, 
//the non specified functions still need to be converted into 'consts' instead of 'zfun'
if( (not f.preconditions.isEmpty() ) or (not f.postconditions.isEmpty())){

///////////////////////////////////////////////////////////////////////////////
//STEP 1: to generate zfun String
if(f.parameters.size()=1){

//TO DO
//here I only consider the parameter type to be SeqType
// I have not consider the function type to be SeqType
if(f.parameters.at(0).type.isTypeOf(SeqType)){
"this is a SeqType".println();
("zfun "+f.name+ "(" + f.parameters.at(0).name+"::\" "+ f.parameters.at(0).type.domain.ref.name +" list \")::"+ f.type).println();
function_string="zfun "+f.name+ "(" + f.parameters.at(0).name+"::\" "+ f.parameters.at(0).type.domain.ref.name +" list \")::"+ f.type.zmType();
}
else 
if(f.parameters.at(0).type.isTypeOf(TypeRef)){
("zfun "+f.name+ "(" + f.parameters.at(0).name+":: "+ f.parameters.at(0).type.zmType() +")::"+ f.type.zmType()).println();

function_string="zfun "+f.name+ "(" + f.parameters.at(0).name+":: "+ f.parameters.at(0).type.zmType() +")::"+ f.type.zmType();
}}
//CASE 2: multiple parameters, we will need (p,p) pattern in ZM

else if(f.parameters.size()>1){

// generate the first part of parameter
if(f.parameters.at(0).type.isTypeOf(SeqType)){
"SeqType domain: ".println();
//f.parameters.at(0).type.domain.ref.name.println();
function_string=f.parameters.at(0).name+ "::"+ f.parameters.at(0).type.domain.ref.name;
} else if(f.parameters.at(0).type.isTypeOf(TypeRef)){
//f.parameters.at(0).type.zmType().println();
function_string=f.parameters.at(0).name+ "::"+f.parameters.at(0).type.zmType();
}

// generate the rest part of parameter: (X parameter_type)*
var i=1;
while(i<f.parameters.size()){

if(f.parameters.at(i).type.isTypeOf(SeqType)){
"SeqType domain: ".println();
f.parameters.at(i).type.domain.ref.name.println();
function_string=function_string+", " + f.parameters.at(i).name+ "::"+f.parameters.at(i).type.domain.ref.name;
} else if(f.parameters.at(i).type.isTypeOf(TypeRef)){
//f.parameters.at(i).type.zmType().println();
function_string=function_string+", " +f.parameters.at(i).name+ "::"+ f.parameters.at(i).type.zmType();
}

i++;
}
function_string="zfun "+f.name+ "("+function_string+"):: "+ f.type.zmType();
}
%]

[%=function_string%]
[%
///////////////////////////////////////////////////////////////////////////////
//STEP 2: to generate precondition String

if(not f.preconditions.isEmpty()){
for (precond in f.preconditions){
precond_string="precondition \""+precond.binaryExpString()+"\"";
precond_string.println();
%]
[%=precond_string%]
[%
}

}









///////////////////////////////////////////////////////////////////////////////
//STEP 3: to generate postcondition String


if(not f.postconditions.isEmpty()){

for(postcond in f.postconditions){

//CASE 1: postcondition=forall, 3 segments
if(postcond.isTypeOf(Forall)){

//Segment 1: variables
var quantity_string: String;
//Metamodel: forall-> quantifierExpression which has 3 attributes: variables, suchthat, predicate
for(variable in postcond.variables){
//TO DO
//here I only consider situation of one variable
//needs to extend to cover multi variables in quantifier 
if(variable.type.isTypeOf(TypeRef)){
quantity_string= "\\<forall> " +variable.name+"::"+ variable.type.ref.name;
quantity_string.println();
}
}

//Segment2: 
postcond.suchthat.println();
var suchthat_string: String;
if(postcond.suchthat.isTypeOf(And)){
suchthat_string=postcond.suchthat.andString();
postcond.suchthat.andString().println();}
else if(postcond.suchthat.isTypeOf(LessThan) or postcond.suchthat.isTypeOf(LessOrEqual) or postcond.suchthat.isTypeOf(Equals) or postcond.suchthat.isTypeOf(GreaterThan)){
suchthat_string=postcond.suchthat.binaryExpString();
postcond.suchthat.binaryExpString().println();
}


//Segment 3:
var predicate_string: String;
postcond.predicate.println();
if(postcond.predicate.isTypeOf(CallExp)){
predicate_string=postcond.predicate.callExpString();
postcond.predicate.callExpString().println();
}
else if(postcond.predicate.isTypeOf(Equals)){
predicate_string=postcond.predicate.equalsString();
}else if(postcond.predicate.isTypeOf(And)){
predicate_string=postcond.predicate.andString();
postcond.predicate.andString().println();
}

postcond_string="postcondition "+"\""+quantity_string+". "+suchthat_string+" \\<longrightarrow> "+predicate_string+"\"";
postcond_string.println();%]
[%=postcond_string%]
[%
}



//CASE 2: postcondition=exist
else
if(postcond.isTypeOf(Exists)){
//Segment 1: QUANTIFIER
var quantity_string: String;
//Metamodel: forall-> quantifierExpression
for(variable in postcond.variables){
//TO DO
//here I only consider situation of one variable
//needs to extend to cover multi variables in quantifier 
if(variable.type.isTypeOf(TypeRef)){
quantity_string= "\\<exists> " +variable.name+"::"+ variable.type.ref.name;
quantity_string.println();
}
}

//Segment2: 
postcond.suchthat.println();
var suchthat_string: String;
if(postcond.suchthat.isTypeOf(And)){
suchthat_string=postcond.suchthat.andString();
postcond.suchthat.andString().println();}
else if(postcond.suchthat.isTypeOf(LessThan) or postcond.suchthat.isTypeOf(LessOrEqual) or postcond.suchthat.isTypeOf(Equals) or postcond.suchthat.isTypeOf(GreaterThan)){
suchthat_string=postcond.suchthat.binaryExpString();
postcond.suchthat.binaryExpString().println();
}


//Segment 3:
var predicate_string: String;
postcond.predicate.println();
if(postcond.predicate.isTypeOf(CallExp)){
predicate_string=postcond.predicate.callExpString();
postcond.predicate.callExpString().println();
}
else if(postcond.predicate.isTypeOf(Equals)){
predicate_string=postcond.predicate.equalsString();
}else if(postcond.predicate.isTypeOf(And)){
//TO DO, need to add more sub-operations to support location function
predicate_string=postcond.predicate.andString();
postcond.predicate.andString().println();
}

postcond_string="postcondition "+"\""+quantity_string+". "+suchthat_string+" \\<longrightarrow> "+predicate_string+"\"";
"postcond_string:".println();
postcond_string.println();%]
[%=postcond_string%]
[%
}

//CASE 3: postcondition=ifexpression
else
if(postcond.isTypeOf(IfExpression)){
//TO DO
}

//CASE 4: postcondition=Equals
else
if(postcond.isTypeOf(Equals)){
postcond_string="postcondition \""+postcond.equalsString()+"\"";
postcond_string.println();%]
[%=postcond_string%]
[%
}


}



}




}

}
















%]

subsection \<open> State Space \<close>
[%
/////////////////////////////////////////////////////////////////////
//query for the statemachine and variables and consts TO generate zstore
"/////////////////////////////////////////////////////////////////////".println();
"variable query TO generate zstore".println();
var stm_name: String;
for (stm in p.machines){ 
//("stm.name: "+stm.name).println();
stm_name=stm.name;
}%]

zstore [%=stm_name%] =
[%

//Part 1 of zstore is variables from variableLsit
"&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&".println();
for (vrl in p.machines.at(0).variableList)
{
"vrl".println();
vrl.println();

("vrl.vars.size(): "+vrl.vars.size()).println();
 "".println();
//("vrl.var): "+vrl.vars).println();
//vrl.modifier.literal.println();
//vrl.vars.at(i).modifier.literal.println();
//vrl.vars.at(i).modifier.literal.at(0).println();
var i=0;
while(i< vrl.vars.size()){
//vrl.vars.at(i).at(0).type.println();
var variable_string: String;
if(vrl.vars.at(i).modifier.literal="VAR"){
if(vrl.vars.at(i).type.isTypeOf(TypeRef)){
variable_string=vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.ref.name +"\"";
//("variable_string: " +variable_string).println();
}
else if(vrl.vars.at(i).type.isTypeOf(SeqType)){
variable_string=vrl.vars.at(i).name+ " :: \"" + vrl.vars.at(i).type.domain.ref.name +" list\"";
}
}

%]  [%=variable_string%]
  [%
i++;} }





//Part 2 is events to be converted into bool variables in zstore
for (e in p.machines.at(0).events)
{ 

%]  event_[%=e.name%]::"bool"
[%


}
%]  act_st::"ProperState"
  desired_st::"ProperState set"
  clock::"integer"
where inv: "To be entered manually"

subsection \<open> Operations \<close>

[%
/////////////////////////////////////////////////////////////////////
//query for the transitions TO zoperations
"/////////////////////////////////////////////////////////////////////".println();
"transitions query TO generate zoperations".println();
//zoperations_string is used for zmachine section
//zoperations_set is used for the lemma of structural invariant section
var zoperations_string:String;
var zoperations_set: OrderedSet;
var zop_name: String;

//this para_string is a set to contain all the parameter in para segment, and will be used for lemma generation

for (tr in p.machines.at(0).transitions){ 
var para_string: OrderedSet;

"START NEW TRANSITION QUERY".println();
("tr.name: "+tr.name).println();

/*
//the following lines have been replaced by the zmState() operation
if(tr.source.isTypeOf(Initial)){
("zoperation InitialTo"+tr.target.name+" =").println();
zop_name="InitialTo"+tr.target.name;}
else if(tr.source.isTypeOf(State)){
if(tr.target.isTypeOf(Final)){
("zoperation "+tr.source.name+"ToFinal =").println();
zop_name=tr.source.name+"ToFinal";
}else
{("zoperation "+tr.source.name+"To"+tr.target.name+" =").println();
zop_name=tr.source.name+"To"+tr.target.name;
}
}
*/

zop_name=tr.source.zmStateCapt()+"To"+tr.target.zmStateCapt();
zop_name.println();

//*******************************
//to define a tuple for this transition to link the hasPara with the zop
//this is for the lemma generation. If a zoperation has a para, then we need l in the lemma
//if zoperation has no para, then we add () in the lemma
var zop_tuple = new Tuple;
zop_tuple.name = zop_name;
zop_tuple.hasPara = false;
zop_tuple.paras = para_string;


zoperations_string=zoperations_string+" "+ zop_name;

%]
zoperation [%=zop_name%] =
  over [%=stm_name%]
[%
//////////////////////////////////////////////////////
//query for the transitions TO generate params section using Input type events
//CASE 1 input event in transition.trigger
var params_string:String;
params_string="";
if(tr.trigger.isDefined() and tr.trigger._type.isDefined() and tr.trigger._type.name="INPUT")
{


if(tr.trigger.parameter.type.isTypeOf(TypeRef)){
params_string=params_string+ tr.trigger.parameter.name+" \\<in> \"" + tr.trigger.parameter.type.ref.name +"\" ";
}
else 
////it does not work with if(vrl.vars.at(i).at(0).type=SeqRef), so use the keyword 'domain'
if(tr.trigger.parameter.type.isTypeOf(SeqType)){
params_string= params_string+ tr.trigger.parameter.name+" \\<in> \"Seq" + tr.trigger.parameter.type.domain.ref.name+"\" ";
}

zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.trigger.parameter.name);
}

//CASE 2 input event in transition.action, and there is only one action
if(tr.action.isDefined() and tr.action.isTypeOf(CommunicationStmt) and  tr.action.communication._type.name="INPUT"){



if(tr.action.communication.parameter.type.isTypeOf(TypeRef)){
params_string=params_string + tr.action.communication.parameter.name+" \\<in> \"" + tr.action.communication.parameter.type.ref.name +"\" ";
} 
else if(tr.action.parameter.type.isTypeOf(SeqType)){
params_string=params_string + tr.action.communication.parameter.name+" \\<in> \"Seq" + tr.action.communication.parameter.type.domain.ref.name +"\"";
}
zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.action.communication.parameter.name);
}


//CASE 3 input event in transition.action, and there are MULTIPLE actionS
else if(tr.action.isDefined() and tr.action.isTypeOf(SeqStatement)){
var i=0;
while(i<tr.action.statements.size())
{
if(tr.action.statements.at(i).isTypeOf(CommunicationStmt) and  tr.action.statements.at(i).communication._type.name="INPUT"){
if(tr.action.statements.at(i).communication.parameter.type.isTypeOf(TypeRef)){
params_string=params_string + tr.action.statements.at(i).communication.parameter.name+" \\<in> \"" + tr.action.statements.at(i).communication.parameter.type.ref.name +"\" ";
} 
else if(tr.action.parameter.type.isTypeOf(SeqType)){
params_string=params_string + tr.action.statements.at(i).communication.parameter.name+" \\<in> \"Seq" + tr.action.statements.at(i).communication.parameter.type.domain.ref.name +"\"";
}
zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.action.statements.at(i).communication.parameter.name);

i++;
}}}


//CASE 4 input event in tr.target.action, and there is only one action
if(tr.target.actions.notEmpty()and (tr.target.actions.at(0).isTypeOf(EntryAction) or tr.target.actions.at(0).isTypeOf(DuringAction)) ){

if(tr.target.actions.at(0).action.isTypeOf(CommunicationStmt) and tr.target.actions.at(0).action.communication._type.name="INPUT"){


if(tr.target.actions.at(0).action.communication.parameter.type.isTypeOf(TypeRef)){
params_string=params_string + tr.target.actions.at(0).action.communication.parameter.name+" \\<in> \"" + tr.target.actions.at(0).action.communication.parameter.type.ref.name +"\" ";
} 
else if(tr.target.actions.at(0).action.parameter.type.isTypeOf(SeqType)){
params_string=params_string + tr.target.actions.at(0).action.communication.parameter.name+" \\<in> \"Seq" + tr.target.actions.at(0).action.communication.parameter.type.domain.ref.name +"\"";
}
zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.target.actions.at(0).action.communication.parameter.name);
}

//CASE 5: input event in tr.target.action, action.isTypeOf(SeqStatement), this is for multiple actions
else if(tr.target.actions.at(0).action.isTypeOf(SeqStatement)){

var i=0;
while(i<tr.target.actions.at(0).action.statements.size())
{

if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(CommunicationStmt) and tr.target.actions.at(0).action.statements.at(i).communication._type.name="INPUT"){
if(tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.isTypeOf(TypeRef)){
params_string=params_string + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name+" \\<in> \"" + tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.ref.name +"\" ";
} 
else if(tr.target.actions.at(0).action.statements.at(i).parameter.type.isTypeOf(SeqType)){
params_string=params_string + tr.target.actions.at(0).action.statements.at(i).communication.parameter.name+" \\<in> \"Seq" + tr.target.actions.at(0).action.statements.at(i).communication.parameter.type.domain.ref.name +"\"";
}
zop_tuple.hasPara = true;
zop_tuple.paras.add(tr.target.actions.at(0).action.statements.at(i).communication.parameter.name);
}

i++;
}

}
}



if(zop_tuple.hasPara){%]
  params [%=params_string %]
[%
}




zoperations_set.add(zop_tuple);


//////////////////////////////////////////////////////
//query the transitions TO generate pre section
//SUBSECTION 1:state constraint: act_st(source) and desired_st(target)
var pre_string: String;

/*
//these 7 lines have been replaced by zmState()
if(tr.source.isTypeOf(Initial)){
("pre \"act_st= initial").println();
pre_string="pre \"act_st= initial";}
else {
("pre \"act_st= "+tr.source.name+"\"").println();
pre_string="pre \"act_st= "+tr.source.name;
}
*/
pre_string="pre \"act_st= "+tr.source.zmState();

//SUBSECTION 2:transition condition -> pre
if (tr.condition.isDefined() )
{
("tr.condition: " + tr.condition).println();

pre_string=pre_string+" \\<and> "+ tr.condition.binaryExpString();

}



//SUBSECTION 3:transition trigger of Simple/input/output event  -> this should be converted to a 'pre' section
if(tr.trigger.isDefined()and tr.trigger.event.isDefined() ){


pre_string=pre_string+" \\<and> event_"+ tr.trigger.event.name;
}


//SUBSECTION 4:transition reset  to pre (TIME property)
if(not tr.reset.isEmpty() ){
tr.name.println();
tr.reset.clock.name.println();
pre_string=pre_string+" \\<and> clock=0";
}



pre_string=pre_string+"\"";
pre_string.println();
%]
  [%=pre_string%]
[%

//////////////////////////////////////////////////////
//query for the transitions TO generate UPDATE section
//SUBSECTION 1:state update
var target_state_update: String;

//we assume there is always update section in zoperation
//because we create zoperation according to the transitions
//the only exception is the Shine operation for the animation purpose
//if we allow zoperation without update section
//then we need to add an IF condition on top of the update section
//if(cond1 and cond2 and cond3) {}


target_state_update=tr.target.zmState();
"target_state_update".println();
target_state_update.println();
var desired_state_set: String;
desired_state_set="{";
for (transition in p.machines.at(0).transitions){
if (transition.source=tr.target){
if( desired_state_set="{"){
desired_state_set= desired_state_set+transition.target.zmState();}
else {
desired_state_set= desired_state_set+ ", "+transition.target.zmState();}

desired_state_set.println();
}
}
desired_state_set=desired_state_set+"}";
%]
  update "[ act_st\<Zprime>= [%=tr.target.zmState()%]
  		  , desired_st\<Zprime>= [%=desired_state_set%]
[%




//SUBSECTION 2:transition action to update, simple/input/output event considered
if (tr.action.isDefined() )
{
//("tr.action: " + tr.action).println();
var tr_action_string:String;

//CASE 1: "SeqStatement" means there are MORE THAN ONE actions.
//currently output type events are negleted in transformation
if(tr.action.isTypeOf(SeqStatement)){
//tr.action.statements.println();
//"tr.action.statements.size():".println();
var i=0;
while(i<tr.action.statements.size())
{

//here I only consider the assignment action
//so there is only one condition on the top as if(tr.action.statements.at(i).isTypeOf(Assignment)),
//and  no "else if" followed
//if the use case has other type of action that needs transformation
//I will add a new IF section after this IF 
if(tr.action.statements.at(i).isTypeOf(Assignment)){
//"left type:".println();

//tr.action.statements.at(i).left.type().println();
//"left type:".println();
//tr.action.statements.at(i).right.type().println();
"tr.action.assignment left.name.name: ".println();
tr.action.statements.at(i).left.name.name.println();


//In GasAnalysis there are 3 different assignment in the transition actions
//The left is always the same: type is VarRef, the query code is left.name.name
//but for the assignment.right we now have 3 types:
//SeqExp, EnumExp, CallExp
// so we need three IF to cover these 3 different types
//if there are new types later on, we need to add more

//CASE 1: right = CallExp
if(tr.action.statements.at(i).right.isTypeOf(CallExp)){
var callExp_string: String;

callExp_string= tr.action.statements.at(i).right.callExpString();
//"callExp_string:".println();
//callExp_string.println();

tr_action_string=", "+tr.action.statements.at(i).left.name.name+"\\<Zprime> = "+callExp_string;



}
//CASE 2: right = SeqExp
//for this type, ONE MORE thing: need to convert to list in ZMachine
else if(tr.action.statements.at(i).right.isTypeOf(SeqExp)){
tr_action_string=", "+tr.action.statements.at(i).left.name.name+"\\<Zprime> ="+tr.action.statements.at(i).right.sequenceString();

//"right SeqExp: ".println();
//tr.action.statements.at(i).right.values.println();
//"right SeqExp size: ".println();
//tr.action.statements.at(i).right.values.size().println();
}
//CASE 3: right = EnumExp
else if(tr.action.statements.at(i).right.isTypeOf(EnumExp)){
"right EnumExp: ".println();
tr.action.statements.at(i).right.type.name.println();
tr.action.statements.at(i).right.literal.name.println();
tr_action_string=", "+tr.action.statements.at(i).left.name.name+"\\<Zprime> = "+tr.action.statements.at(i).right.literal.name;
}

%]
         [%=tr_action_string%]
[%
}


i++;
}
//"tr.action.statements.at(0)".println();
//tr.action.statements.at(0).println();
//"tr.action.statements.at(1):".println();
//tr.action.statements.at(1).println();

}


//CASE 2: single action in tr.actions
//in GA use case, the single action is the type of CommunicationStmt
//all are events,
//this else if is to map L808 'if(tr.action.isTypeOf(SeqStatement))' for the situation of multiple actions
//besides this else if,  can be more else IF
//but in the GA and movement example, we only need this else IF
//so more ELSE IF can be added later for new cases
else if(tr.action.isTypeOf(CommunicationStmt)){
//TODO
//currently, I don't consider the output or input event in the actions.
//the input event can exist in transition action, but 
// is considered in the 'para' segment 

if(tr.action.communication._type.name="SIMPLE" or tr.action.communication._type.name="INPUT" or tr.action.communication._type.name="OUTPUT"){
tr_action_string=", event_"+tr.action.communication.event.name +"\\<Zprime> = True";
}
%]
         [%=tr_action_string%]
[%
}

}


/////////////////////////////////////////////////////////////////////
//query for the target state enter action TO generate update section
//TO DO
//currently, only cover the types of actions used in GasAnalysis
//i.e. the assignment with right=callexp
//I need to generate an operation for tr.action and tr.target.action
//to cover as many types as possible and to simplify the codes
//in this version, tr.action has more types than tr.target.aciton

// we can not use if(tr.target.actions.isDefined()), it returns True no matter there is state actions or not.
if(tr.target.actions.notEmpty()and (tr.target.actions.at(0).isTypeOf(EntryAction) or tr.target.actions.at(0).isTypeOf(DuringAction)) ){

("tr.target.actions.size:" +tr.target.actions.size()).println();
("tr.target.actions:" +tr.target.actions.at(0)).println();
//tr.target.actions.at(0).isTypeOf(Assignment).println();
//tr.target.actions.at(0).isTypeOf(Statement).println();
//tr.target.actions.at(0).isTypeOf(Action).println();
tr.target.actions.at(0).type().println();
tr.target.actions.at(0).action.println();

var target_action_string: String;

//CASE 1: action.isTypeOf(Assignment)
if(tr.target.actions.at(0).action.isTypeOf(Assignment)){
//to get the left parameter
tr.target.actions.at(0).action.left.name.name.println();
tr.target.actions.at(0).action.right.args.size().println();

//if the RIGHT = CallExp
if (tr.target.actions.at(0).action.right.isTypeOf(CallExp)){
//CallExp means  calling functions


target_action_string=tr.target.actions.at(0).action.left.name.name+"\\<Zprime> ="+tr.target.actions.at(0).action.right.callExpString();

}%]
          , [%=target_action_string%]
[%
}
//CASE 2: action.isTypeOf(Call)
//the action is an operation
else if(tr.target.actions.at(0).action.isTypeOf(Call)){
target_action_string=tr.target.actions.at(0).action.callString();
%]
          , [%=target_action_string%]
[%
}


//CASE 3: action.isTypeOf(CommunicationStmt)
//the action is an event
else if(tr.target.actions.at(0).action.isTypeOf(CommunicationStmt)){

if(tr.target.actions.at(0).action.communication._type.name="SIMPLE" or tr.target.actions.at(0).action.communication._type.name="INPUT" or tr.target.actions.at(0).action.communication._type.name="OUTPUT"){
target_action_string="event_"+tr.target.actions.at(0).action.communication.event.name +"\\<Zprime> = True";
%]
          , [%=target_action_string%]
[%
}
}

//CASE 4: action.isTypeOf(SeqStatement), this is for multiple actions
else if(tr.target.actions.at(0).action.isTypeOf(SeqStatement)){

var i=0;
while(i<tr.target.actions.at(0).action.statements.size())
{
if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(Assignment)){
if (tr.target.actions.at(0).action.statements.at(i).right.isTypeOf(CallExp)){
target_action_string=tr.target.actions.at(0).action.statements.at(i).left.name.name+"\\<Zprime> ="+tr.target.actions.at(0).action.statements.at(i).right.callExpString();
}%]
          , [%=target_action_string%]
[%}
else if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(Call)){
//TODO
target_action_string=tr.target.actions.at(0).action.statements.at(i).callString();
%]
          , [%=target_action_string%]
[%}

else if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(CommunicationStmt)){
if(tr.target.actions.at(0).action.statements.at(i).communication._type.name="SIMPLE" or tr.target.actions.at(0).action.statements.at(i).communication._type.name="INPUT" or tr.target.actions.at(0).action.statements.at(i).communication._type.name="OUTPUT"  ){
target_action_string="event_"+tr.target.actions.at(0).action.statements.at(i).communication.event.name +"\\<Zprime> = True";
%]
          , [%=target_action_string%]
[%
}
}

else if(tr.target.actions.at(0).action.statements.at(i).isTypeOf(Wait)){
//TODO
target_action_string="clock\\<Zprime> = clock + "+tr.target.actions.at(0).action.statements.at(i).duration.binaryExpString();
%]
          , [%=target_action_string%]
[%
}

i++;
}
}

}%]
          ]"
        
[%
//'}' in the line below is the close end of transition for loop
}
%]
zoperation Shine =
  over [%=stm_name%]
  params s\<in>"{act_st}"
  
definition Init :: "[%=stm_name%] subst" where
  [z_defs]:
  "Init = 
  [\<leadsto>]"
(*To be filled in by user*)
  
  
zmachine [%=stm_name%]Machine =
  init Init
  operations [%=zoperations_string%] Shine

animate [%=stm_name%]Machine


subsection \<open> Structural Invariants \<close>

lemma Init_inv: "Init establishes [%=stm_name%]_inv"
  by zpog_full

[%
var n=0;
while (n<zoperations_set.size())
{
if(zoperations_set.at(n)!="initial"){
if(zoperations_set.at(n).hasPara){

%]
lemma [%=zoperations_set.at(n).name%]_inv: "[%=zoperations_set.at(n).name%] [%=zoperations_set.at(n).paras.toparathString()%] preserves [%=stm_name%]_inv"
  by (zpog_full; auto)
  
[%
} else if(not zoperations_set.at(n).hasPara){
%]
lemma [%=zoperations_set.at(n).name%]_inv: "[%=zoperations_set.at(n).name%]() preserves [%=stm_name%]_inv"
  by (zpog_full; auto)
  
[%

}

}
n++;
}
%]

[%
// '}' in the line below is the close end of package scope: if (p.name="Chemical")
}
}

%]
end

[%
operation OrderedSet toparathString(): String{

var str:String;
str=self.at(0);
var i=1;
while(i<self.size()){
str= str+", "+self.at(i);
i++;
}
str="("+str + ")";
return str;

}
%]








[*convert initial state name from i1 to initial, final j1 to final*]
[%
operation RC!Node zmState(): String{
  if(self.isTypeOf(Initial)){
  return "initial";
  } else if(self.isTypeOf(Final)){
    return "final";
  } else{
  return self.name;
  }
  }%]
  

[*convert initial state name from i1 to Initial, final j1 to Final*]
[%
operation RC!Node zmStateCapt(): String{
  if(self.isTypeOf(Initial)){
  return "Initial";
  } else if(self.isTypeOf(Final)){
    return "Final";
  } else{
  return self.name;
  }
  }%]
  
  
[*convert boolean type to bool type*]
[%
operation RC!Type zmType(): String{
  if(self.ref.name="boolean"){
  return "bool";
  } else{
  return self.ref.name;
  }
  }%]
  
  
  
 [%
 
operation RC!Expression binaryExpString(): String{
//"self.type".println();
//self.type.println();
if(self.isTypeOf(LessThan)){
return self.lessThanString();}
else if(self.isTypeOf(GreaterThan)){
return self.greaterThanString();}
else if(self.isTypeOf(LessOrEqual)){
return self.lessOrEqualString();}
else if(self.isTypeOf(GreaterOrEqual)){
return self.greaterOrEqualString();}
else if(self.isTypeOf(Equals)){
return self.equalsString();}
else if (self.isTypeOf(And)){
return self.andString();}
else if (self.isTypeOf(Or)){
return self.orString();}
else if (self.isTypeOf(Not)){
return self.notString();}
else if (self.isTypeOf(Plus)){
return self.plusString();}
else if (self.isTypeOf(Minus)){
return self.minusString();}
else if(self.isTypeOf(IntegerExp) or self.isTypeOf(RefExp) or self.isTypeOf(CallExp)  or self.isTypeOf(ResultExp) or self.isTypeOf(Selection) or self.isTypeOf(EnumExp) or self.isTypeOf(ClockExp)  ){
return self.oneSideOfBianryString();}
else if(self.isTypeOf(ParExp)){
return self.exp.binaryExpString();
}
}
%]
[%

operation RC!Expression lessThanString(): String{
return self.left.binaryExpString() +"<" + self.right.binaryExpString();
}
%]

[%
operation RC!Expression lessOrEqualString(): String{
return self.left.binaryExpString() +"\\<le>" + self.right.binaryExpString();
}
%]

[%
operation RC!Expression greaterThanString(): String{
return self.left.binaryExpString() +">" + self.right.binaryExpString();
}
%]

[%
operation RC!Expression greaterOrEqualString(): String{
return self.left.binaryExpString() +"\\<ge>" + self.right.binaryExpString();
}
%]

[%
operation RC!Expression equalsString(): String{
return self.left.binaryExpString() +"= (" + self.right.binaryExpString()+")";
}
%]
[%
operation RC!Expression andString(): String{
return self.left.binaryExpString() +" \\<and> " + self.right.binaryExpString();
}
%]

[%
operation RC!Expression orString(): String{
return "("+self.left.binaryExpString() +" \\<or> " + self.right.binaryExpString()+")";
}
%]

[%
operation RC!Expression notString(): String{
return "\\<not>" + self.exp.binaryExpString();
}
%]

[%
operation RC!Expression plusString(): String{
return "("+self.left.binaryExpString() +" + " + self.right.binaryExpString()+")";
}
%]

[%
operation RC!Expression minusString(): String{
return "("+self.left.binaryExpString() +" - " + self.right.binaryExpString()+")";
}
%]

[%
//DONE
//to return the string of left or right expression string of the binary expression
//currently covers 3 types: Integer, RefExp, CallExp
operation RC!Expression oneSideOfBianryString(): String{
if(self.isTypeOf(IntegerExp)){
return self.value.toString();
}
else if(self.isTypeOf(RefExp)){
//self.ref.name.println();
return self.ref.name;
}
else if(self.isTypeOf(CallExp)){
//self.callExpString().println();
return self.callExpString();
}
else if(self.isTypeOf(ResultExp)){
return "result";
}
else if(self.isTypeOf(Selection)){
return self.member.name+"("+self.receiver.value.ref.name+"!"+self.receiver.parameters.at(0).ref.name+")";
}

else if(self.isTypeOf(EnumExp)){
return self.literal.name;
}

else if(self.isTypeOf(ClockExp)){
return "clock";
}
}
 
 %]
  
 
  
  
  
[*to generate the CallExp expression string for the statement of CallExp type, i.e. functions*]
[% 
operation RC!CallExp callExpString(): String{
var args_string: String;
var callExp_string: String;
//to get the parameter on the right

if(self.args.at(0).isTypeOf(RefExp)){
args_string= self.args.at(0).ref.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(0).isTypeOf(ResultExp)){
args_string= "result";
}
else
if(self.args.at(0).isTypeOf(Selection)){
args_string=self.args.at(0).member.name+"("+self.args.at(0).receiver.value.ref.name+"!"+self.args.at(0).receiver.parameters.at(0).ref.name+")";
}

//for the case that there are more than 2 args, we need insert ',' between args
var j=1;
while(j<self.args.size()){
//"self.args.at(j).type:".println();
//self.args.at(j).type.println();


if(self.args.at(j).isTypeOf(RefExp)){
args_string=args_string+ ", "+ self.args.at(j).ref.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(j).isTypeOf(ResultExp)){
args_string=args_string+ ", "+ "result";
}
else
if(self.args.at(j).isTypeOf(Selection)){
self.args.at(j).receiver.println();
//ArrayExp []
//self.args.at(j).receiver.value.type.println();
//self.args.at(j).receiver.value.ref.name.println();
//gs
//self.args.at(j).receiver.parameters.at(0).ref.name.println();
//x
//self.args.at(j).member.name.println();
//i
args_string= args_string+ ", "+self.args.at(j).member.name+"("+self.args.at(j).receiver.value.ref.name+"!"+self.args.at(j).receiver.parameters.at(0).ref.name+")";
//i(gs!x)
}

//????shall j++ inside or outside?
j++;
}

callExp_string=self.`function`.ref.name+"("+args_string+")";
return callExp_string;
}
  %]
  
  
  
  
  

[*to generate the Call expression string for the statement of Call type, i.e. operations*]
[% 
operation RC!Call callString(): String{
var args_string: String;
var call_string: String;
//to get the parameter on the right
if(self.args.size()=0){
args_string="";
}
else if(self.args.size()>0){
if(self.args.at(0).isTypeOf(RefExp)){
args_string= self.args.at(0).ref.name;
}
else if(self.args.at(0).isTypeOf(IntegerExp)){
args_string= self.args.at(0).value.toString();
}
else if(self.args.at(0).isTypeOf(EnumExp)){
args_string= self.args.at(0).literal.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(0).isTypeOf(ResultExp)){
args_string= "result";
}
else
if(self.args.at(0).isTypeOf(Selection)){
args_string=self.args.at(0).member.name+"("+self.args.at(0).receiver.value.ref.name+"!"+self.args.at(0).receiver.parameters.at(0).ref.name+")";
}

//for the case that there are more than 2 args, we need insert ',' between args
var j=1;
while(j<self.args.size()){
//"self.args.at(j).type:".println();
//self.args.at(j).type.println();


if(self.args.at(j).isTypeOf(RefExp)){
args_string=args_string+ ", "+ self.args.at(j).ref.name;
}
else if(self.args.at(j).isTypeOf(IntegerExp)){
args_string= args_string+ ", "+ self.args.at(j).value.toString();
}
else if(self.args.at(j).isTypeOf(EnumExp)){
args_string= args_string+ ", "+ self.args.at(j).literal.name;
}
else 
//this branch is for callexp used in functions where we have the keyword result
if(self.args.at(j).isTypeOf(ResultExp)){
args_string=args_string+ ", "+ "result";
}
else
if(self.args.at(j).isTypeOf(Selection)){
self.args.at(j).receiver.println();
//ArrayExp []
//self.args.at(j).receiver.value.type.println();
//self.args.at(j).receiver.value.ref.name.println();
//gs
//self.args.at(j).receiver.parameters.at(0).ref.name.println();
//x
//self.args.at(j).member.name.println();
//i
args_string= args_string+ ", "+self.args.at(j).member.name+"("+self.args.at(j).receiver.value.ref.name+"!"+self.args.at(j).receiver.parameters.at(0).ref.name+")";
//i(gs!x)
}

//????shall j++ inside or outside?
j++;
}
}
call_string=self.`operation`.name+"("+args_string+")";
return call_string;
}
  %]
  


  
[%
operation RC!SeqExp sequenceString(): String{

if(self.values.size()=0){
return  "[]";
} 
else if(self.values.size()>0) {
var m=1;
var sequence_string="["+self.values.at(0);
while (m<self.values.size()){
sequence_string=sequence_string+", "+self.values.at(m);
m++;
}
sequence_string=sequence_string+"]";
return sequence_string;
}
}
%]


[%
operation RC!SeqExp sequenceString(): String{

if(self.values.size()=0){
return  "[]";
} 
else if(self.values.size()>0) {
var m=1;
var sequence_string="["+self.values.at(0);
while (m<self.values.size()){
sequence_string=sequence_string+", "+self.values.at(m);
m++;
}
sequence_string=sequence_string+"]";
return sequence_string;
}
}
%]


